"use strict";

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseScraperWithBrowser = exports.LoginResults = void 0;

var _puppeteer = _interopRequireDefault(require("puppeteer"));

var _baseScraper = require("./base-scraper");

var _navigation = require("../helpers/navigation");

var _elementsInteractions = require("../helpers/elements-interactions");

var _debug = require("../helpers/debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const VIEWPORT_WIDTH = 1024;
const VIEWPORT_HEIGHT = 768;
const OK_STATUS = 200;
const debug = (0, _debug.getDebug)('base-scraper-with-browser');
var LoginBaseResults;

(function (LoginBaseResults) {
  LoginBaseResults["Success"] = "SUCCESS";
  LoginBaseResults["UnknownError"] = "UNKNOWN_ERROR";
})(LoginBaseResults || (LoginBaseResults = {}));

const {
  Timeout,
  Generic,
  General
} = _baseScraper.ScraperErrorTypes,
      rest = _objectWithoutProperties(_baseScraper.ScraperErrorTypes, ["Timeout", "Generic", "General"]);

const LoginResults = _objectSpread({}, rest, {}, LoginBaseResults);

exports.LoginResults = LoginResults;

async function getKeyByValue(object, value, page) {
  const keys = Object.keys(object);

  for (const key of keys) {
    // @ts-ignore
    const conditions = object[key];

    for (const condition of conditions) {
      let result = false;

      if (condition instanceof RegExp) {
        result = condition.test(value);
      } else if (typeof condition === 'function') {
        result = await condition({
          page,
          value
        });
      } else {
        result = value.toLowerCase() === condition.toLowerCase();
      }

      if (result) {
        // @ts-ignore
        return Promise.resolve(key);
      }
    }
  }

  return Promise.resolve(LoginResults.UnknownError);
}

function handleLoginResult(scraper, loginResult) {
  switch (loginResult) {
    case LoginResults.Success:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.LoginSuccess);
      return {
        success: true
      };

    case LoginResults.InvalidPassword:
    case LoginResults.UnknownError:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.LoginFailed);
      return {
        success: false,
        errorType: loginResult === LoginResults.InvalidPassword ? _baseScraper.ScraperErrorTypes.InvalidPassword : _baseScraper.ScraperErrorTypes.General,
        errorMessage: `Login failed with ${loginResult} error`
      };

    case LoginResults.ChangePassword:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.ChangePassword);
      return {
        success: false,
        errorType: _baseScraper.ScraperErrorTypes.ChangePassword
      };

    default:
      throw new Error(`unexpected login result "${loginResult}"`);
  }
}

function createGeneralError() {
  return {
    success: false,
    errorType: _baseScraper.ScraperErrorTypes.General
  };
}

class BaseScraperWithBrowser extends _baseScraper.BaseScraper {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "browser", void 0);

    _defineProperty(this, "page", void 0);
  }

  getViewPort() {
    return {
      width: VIEWPORT_WIDTH,
      height: VIEWPORT_HEIGHT
    };
  }

  async initialize() {
    await super.initialize();
    debug('initialize scraper');
    let env;

    if (this.options.verbose) {
      env = _objectSpread({
        DEBUG: '*'
      }, process.env);
    }

    if (typeof this.options.browser !== 'undefined' && this.options.browser !== null) {
      debug('use custom browser instance provided in options');
      this.browser = this.options.browser;
    } else {
      const executablePath = this.options.executablePath || undefined;
      const args = this.options.args || [];
      const {
        timeout
      } = this.options;
      const headless = !this.options.showBrowser;
      debug(`launch a browser with headless mode = ${headless}`);
      this.browser = await _puppeteer.default.launch({
        env,
        headless,
        executablePath,
        args,
        timeout
      });
    }

    if (this.options.prepareBrowser) {
      debug('execute \'prepareBrowser\' interceptor provided in options');
      await this.options.prepareBrowser(this.browser);
    }

    if (!this.browser) {
      debug('failed to initiate a browser, exit');
      return;
    }

    const pages = await this.browser.pages();

    if (pages.length) {
      debug('browser has already pages open, use the first one');
      [this.page] = pages;
    } else {
      debug('create a new browser page');
      this.page = await this.browser.newPage();
    }

    if (this.options.defaultTimeout) {
      this.page.setDefaultTimeout(this.options.defaultTimeout);
    }

    if (this.options.preparePage) {
      debug('execute \'preparePage\' interceptor provided in options');
      await this.options.preparePage(this.page);
    }

    const viewport = this.getViewPort();
    debug(`set viewport to width ${viewport.width}, height ${viewport.height}`);
    await this.page.setViewport({
      width: viewport.width,
      height: viewport.height
    });
    this.page.on('requestfailed', request => {
      var _request$failure;

      debug('Request failed: %s %s', (_request$failure = request.failure()) === null || _request$failure === void 0 ? void 0 : _request$failure.errorText, request.url());
    });
  }

  async navigateTo(url, page, timeout) {
    const pageToUse = page || this.page;

    if (!pageToUse) {
      return;
    }

    const options = _objectSpread({}, timeout === null ? null : {
      timeout
    });

    const response = await pageToUse.goto(url, options); // note: response will be null when navigating to same url while changing the hash part. the condition below will always accept null as valid result.

    if (response !== null && (response === undefined || response.status() !== OK_STATUS)) {
      throw new Error(`Error while trying to navigate to url ${url}`);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  getLoginOptions(_credentials) {
    throw new Error(`getLoginOptions() is not created in ${this.options.companyId}`);
  }

  async fillInputs(pageOrFrame, fields) {
    const modified = [...fields];
    const input = modified.shift();

    if (!input) {
      return;
    }

    await (0, _elementsInteractions.fillInput)(pageOrFrame, input.selector, input.value);

    if (modified.length) {
      await this.fillInputs(pageOrFrame, modified);
    }
  }

  async login(credentials) {
    if (!credentials || !this.page) {
      return createGeneralError();
    }

    debug('execute login process');
    const loginOptions = this.getLoginOptions(credentials);

    if (loginOptions.userAgent) {
      debug('set custom user agent provided in options');
      await this.page.setUserAgent(loginOptions.userAgent);
    }

    debug('navigate to login url');
    await this.navigateTo(loginOptions.loginUrl);

    if (loginOptions.checkReadiness) {
      debug('execute \'checkReadiness\' interceptor provided in login options');
      await loginOptions.checkReadiness();
    } else if (typeof loginOptions.submitButtonSelector === 'string') {
      debug('wait until submit button is available');
      await (0, _elementsInteractions.waitUntilElementFound)(this.page, loginOptions.submitButtonSelector);
    }

    let loginFrameOrPage = this.page;

    if (loginOptions.preAction) {
      debug('execute \'preAction\' interceptor provided in login options');
      loginFrameOrPage = (await loginOptions.preAction()) || this.page;
    }

    debug('fill login components input with relevant values');
    await this.fillInputs(loginFrameOrPage, loginOptions.fields);
    debug('click on login submit button');

    if (typeof loginOptions.submitButtonSelector === 'string') {
      await (0, _elementsInteractions.clickButton)(loginFrameOrPage, loginOptions.submitButtonSelector);
    } else {
      await loginOptions.submitButtonSelector();
    }

    this.emitProgress(_baseScraper.ScaperProgressTypes.LoggingIn);

    if (loginOptions.postAction) {
      debug('execute \'postAction\' interceptor provided in login options');
      await loginOptions.postAction();
    } else {
      debug('wait for page navigation');
      await (0, _navigation.waitForNavigation)(this.page);
    }

    debug('check login result');
    const current = await (0, _navigation.getCurrentUrl)(this.page, true);
    const loginResult = await getKeyByValue(loginOptions.possibleResults, current, this.page);
    debug(`handle login results ${loginResult}`);
    return handleLoginResult(this, loginResult);
  }

  async terminate(_success) {
    debug(`terminating browser with success = ${_success}`);
    this.emitProgress(_baseScraper.ScaperProgressTypes.Terminating);

    if (!_success && !!this.options.storeFailureScreenShotPath) {
      debug(`create a snapshot before terminated in ${this.options.storeFailureScreenShotPath}`);
      await this.page.screenshot({
        path: this.options.storeFailureScreenShotPath,
        fullPage: true
      });
    }

    if (!this.browser) {
      return;
    }

    await this.browser.close();
  }

}

exports.BaseScraperWithBrowser = BaseScraperWithBrowser;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JhcGVycy9iYXNlLXNjcmFwZXItd2l0aC1icm93c2VyLnRzIl0sIm5hbWVzIjpbIlZJRVdQT1JUX1dJRFRIIiwiVklFV1BPUlRfSEVJR0hUIiwiT0tfU1RBVFVTIiwiZGVidWciLCJMb2dpbkJhc2VSZXN1bHRzIiwiVGltZW91dCIsIkdlbmVyaWMiLCJHZW5lcmFsIiwiU2NyYXBlckVycm9yVHlwZXMiLCJyZXN0IiwiTG9naW5SZXN1bHRzIiwiZ2V0S2V5QnlWYWx1ZSIsIm9iamVjdCIsInZhbHVlIiwicGFnZSIsImtleXMiLCJPYmplY3QiLCJrZXkiLCJjb25kaXRpb25zIiwiY29uZGl0aW9uIiwicmVzdWx0IiwiUmVnRXhwIiwidGVzdCIsInRvTG93ZXJDYXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJVbmtub3duRXJyb3IiLCJoYW5kbGVMb2dpblJlc3VsdCIsInNjcmFwZXIiLCJsb2dpblJlc3VsdCIsIlN1Y2Nlc3MiLCJlbWl0UHJvZ3Jlc3MiLCJTY2FwZXJQcm9ncmVzc1R5cGVzIiwiTG9naW5TdWNjZXNzIiwic3VjY2VzcyIsIkludmFsaWRQYXNzd29yZCIsIkxvZ2luRmFpbGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JNZXNzYWdlIiwiQ2hhbmdlUGFzc3dvcmQiLCJFcnJvciIsImNyZWF0ZUdlbmVyYWxFcnJvciIsIkJhc2VTY3JhcGVyV2l0aEJyb3dzZXIiLCJCYXNlU2NyYXBlciIsImdldFZpZXdQb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJpbml0aWFsaXplIiwiZW52Iiwib3B0aW9ucyIsInZlcmJvc2UiLCJERUJVRyIsInByb2Nlc3MiLCJicm93c2VyIiwiZXhlY3V0YWJsZVBhdGgiLCJ1bmRlZmluZWQiLCJhcmdzIiwidGltZW91dCIsImhlYWRsZXNzIiwic2hvd0Jyb3dzZXIiLCJwdXBwZXRlZXIiLCJsYXVuY2giLCJwcmVwYXJlQnJvd3NlciIsInBhZ2VzIiwibGVuZ3RoIiwibmV3UGFnZSIsImRlZmF1bHRUaW1lb3V0Iiwic2V0RGVmYXVsdFRpbWVvdXQiLCJwcmVwYXJlUGFnZSIsInZpZXdwb3J0Iiwic2V0Vmlld3BvcnQiLCJvbiIsInJlcXVlc3QiLCJmYWlsdXJlIiwiZXJyb3JUZXh0IiwidXJsIiwibmF2aWdhdGVUbyIsInBhZ2VUb1VzZSIsInJlc3BvbnNlIiwiZ290byIsInN0YXR1cyIsImdldExvZ2luT3B0aW9ucyIsIl9jcmVkZW50aWFscyIsImNvbXBhbnlJZCIsImZpbGxJbnB1dHMiLCJwYWdlT3JGcmFtZSIsImZpZWxkcyIsIm1vZGlmaWVkIiwiaW5wdXQiLCJzaGlmdCIsInNlbGVjdG9yIiwibG9naW4iLCJjcmVkZW50aWFscyIsImxvZ2luT3B0aW9ucyIsInVzZXJBZ2VudCIsInNldFVzZXJBZ2VudCIsImxvZ2luVXJsIiwiY2hlY2tSZWFkaW5lc3MiLCJzdWJtaXRCdXR0b25TZWxlY3RvciIsImxvZ2luRnJhbWVPclBhZ2UiLCJwcmVBY3Rpb24iLCJMb2dnaW5nSW4iLCJwb3N0QWN0aW9uIiwiY3VycmVudCIsInBvc3NpYmxlUmVzdWx0cyIsInRlcm1pbmF0ZSIsIl9zdWNjZXNzIiwiVGVybWluYXRpbmciLCJzdG9yZUZhaWx1cmVTY3JlZW5TaG90UGF0aCIsInNjcmVlbnNob3QiLCJwYXRoIiwiZnVsbFBhZ2UiLCJjbG9zZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFLQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxjQUFjLEdBQUcsSUFBdkI7QUFDQSxNQUFNQyxlQUFlLEdBQUcsR0FBeEI7QUFDQSxNQUFNQyxTQUFTLEdBQUcsR0FBbEI7QUFFQSxNQUFNQyxLQUFLLEdBQUcscUJBQVMsMkJBQVQsQ0FBZDtJQUVLQyxnQjs7V0FBQUEsZ0I7QUFBQUEsRUFBQUEsZ0I7QUFBQUEsRUFBQUEsZ0I7R0FBQUEsZ0IsS0FBQUEsZ0I7O0FBS0wsTUFBTTtBQUNKQyxFQUFBQSxPQURJO0FBQ0tDLEVBQUFBLE9BREw7QUFDY0MsRUFBQUE7QUFEZCxJQUVGQyw4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R0FBRyxNQUFNbEIsYUFBYSxDQUFDa0YsWUFBWSxDQUFDVyxlQUFkLEVBQStCRCxPQUEvQixFQUF3QyxLQUFLekYsSUFBN0MsQ0FBdkM7QUFDQVgsSUFBQUEsS0FBSyxDQUFFLHdCQUF1QjBCLFdBQVksRUFBckMsQ0FBTDtBQUNBLFdBQU9GLGlCQUFpQixDQUFDLElBQUQsRUFBT0UsV0FBUCxDQUF4QjtBQUNEOztBQUVELFFBQU00RSxTQUFOLENBQWdCQyxRQUFoQixFQUFtQztBQUNqQ3ZHLElBQUFBLEtBQUssQ0FBRSxzQ0FBcUN1RyxRQUFTLEVBQWhELENBQUw7QUFDQSxTQUFLM0UsWUFBTCxDQUFrQkMsaUNBQW9CMkUsV0FBdEM7O0FBRUEsUUFBSSxDQUFDRCxRQUFELElBQWEsQ0FBQyxDQUFDLEtBQUt6RCxPQUFMLENBQWEyRCwwQkFBaEMsRUFBNEQ7QUFDMUR6RyxNQUFBQSxLQUFLLENBQUUsMENBQXlDLEtBQUs4QyxPQUFMLENBQWEyRCwwQkFBMkIsRUFBbkYsQ0FBTDtBQUNBLFlBQU0sS0FBSzlGLElBQUwsQ0FBVStGLFVBQVYsQ0FBcUI7QUFDekJDLFFBQUFBLElBQUksRUFBRSxLQUFLN0QsT0FBTCxDQUFhMkQsMEJBRE07QUFFekJHLFFBQUFBLFFBQVEsRUFBRTtBQUZlLE9BQXJCLENBQU47QUFJRDs7QUFFRCxRQUFJLENBQUMsS0FBSzFELE9BQVYsRUFBbUI7QUFDakI7QUFDRDs7QUFFRCxVQUFNLEtBQUtBLE9BQUwsQ0FBYTJELEtBQWIsRUFBTjtBQUNEOztBQTdMOEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHVwcGV0ZWVyLCB7IEJyb3dzZXIsIEZyYW1lLCBQYWdlIH0gZnJvbSAncHVwcGV0ZWVyJztcblxuaW1wb3J0IHtcbiAgU2NyYXBlckVycm9yVHlwZXMsXG4gIEJhc2VTY3JhcGVyLCBTY2FwZXJTY3JhcGluZ1Jlc3VsdCwgU2NhcGVyUHJvZ3Jlc3NUeXBlcyxcbiAgU2NyYXBlckNyZWRlbnRpYWxzLFxufSBmcm9tICcuL2Jhc2Utc2NyYXBlcic7XG5pbXBvcnQgeyBnZXRDdXJyZW50VXJsLCB3YWl0Rm9yTmF2aWdhdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBjbGlja0J1dHRvbiwgZmlsbElucHV0LCB3YWl0VW50aWxFbGVtZW50Rm91bmQgfSBmcm9tICcuLi9oZWxwZXJzL2VsZW1lbnRzLWludGVyYWN0aW9ucyc7XG5pbXBvcnQgeyBnZXREZWJ1ZyB9IGZyb20gJy4uL2hlbHBlcnMvZGVidWcnO1xuXG5jb25zdCBWSUVXUE9SVF9XSURUSCA9IDEwMjQ7XG5jb25zdCBWSUVXUE9SVF9IRUlHSFQgPSA3Njg7XG5jb25zdCBPS19TVEFUVVMgPSAyMDA7XG5cbmNvbnN0IGRlYnVnID0gZ2V0RGVidWcoJ2Jhc2Utc2NyYXBlci13aXRoLWJyb3dzZXInKTtcblxuZW51bSBMb2dpbkJhc2VSZXN1bHRzIHtcbiAgU3VjY2VzcyA9ICdTVUNDRVNTJyxcbiAgVW5rbm93bkVycm9yID0gJ1VOS05PV05fRVJST1InXG59XG5cbmNvbnN0IHtcbiAgVGltZW91dCwgR2VuZXJpYywgR2VuZXJhbCwgLi4ucmVzdFxufSA9IFNjcmFwZXJFcnJvclR5cGVzO1xuZXhwb3J0IGNvbnN0IExvZ2luUmVzdWx0cyA9IHtcbiAgLi4ucmVzdCxcbiAgLi4uTG9naW5CYXNlUmVzdWx0cyxcbn07XG5cbmV4cG9ydCB0eXBlIExvZ2luUmVzdWx0cyA9IEV4Y2x1ZGU8U2NyYXBlckVycm9yVHlwZXMsXG5TY3JhcGVyRXJyb3JUeXBlcy5UaW1lb3V0XG58IFNjcmFwZXJFcnJvclR5cGVzLkdlbmVyaWNcbnwgU2NyYXBlckVycm9yVHlwZXMuR2VuZXJhbD4gfCBMb2dpbkJhc2VSZXN1bHRzO1xuXG5leHBvcnQgdHlwZSBQb3NzaWJsZUxvZ2luUmVzdWx0cyA9IHtcbiAgW2tleSBpbiBMb2dpblJlc3VsdHNdPzogKHN0cmluZyB8IFJlZ0V4cCB8ICgob3B0aW9ucz86IHsgcGFnZT86IFBhZ2V9KSA9PiBQcm9taXNlPGJvb2xlYW4+KSlbXVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBMb2dpbk9wdGlvbnMge1xuICBsb2dpblVybDogc3RyaW5nO1xuICBjaGVja1JlYWRpbmVzcz86ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGZpZWxkczoge3NlbGVjdG9yOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmd9W107XG4gIHN1Ym1pdEJ1dHRvblNlbGVjdG9yOiBzdHJpbmcgfCAoKCkgPT4gUHJvbWlzZTx2b2lkPik7XG4gIHByZUFjdGlvbj86ICgpID0+IFByb21pc2U8RnJhbWUgfCB2b2lkPjtcbiAgcG9zdEFjdGlvbj86ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHBvc3NpYmxlUmVzdWx0czogUG9zc2libGVMb2dpblJlc3VsdHM7XG4gIHVzZXJBZ2VudD86IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5QnlWYWx1ZShvYmplY3Q6IFBvc3NpYmxlTG9naW5SZXN1bHRzLCB2YWx1ZTogc3RyaW5nLCBwYWdlOiBQYWdlKTogUHJvbWlzZTxMb2dpblJlc3VsdHM+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgY29uZGl0aW9ucyA9IG9iamVjdFtrZXldO1xuXG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbmRpdGlvbi50ZXN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBjb25kaXRpb24oeyBwYWdlLCB2YWx1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGNvbmRpdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoTG9naW5SZXN1bHRzLlVua25vd25FcnJvcik7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUxvZ2luUmVzdWx0KHNjcmFwZXI6IEJhc2VTY3JhcGVyV2l0aEJyb3dzZXIsIGxvZ2luUmVzdWx0OiBMb2dpblJlc3VsdHMpIHtcbiAgc3dpdGNoIChsb2dpblJlc3VsdCkge1xuICAgIGNhc2UgTG9naW5SZXN1bHRzLlN1Y2Nlc3M6XG4gICAgICBzY3JhcGVyLmVtaXRQcm9ncmVzcyhTY2FwZXJQcm9ncmVzc1R5cGVzLkxvZ2luU3VjY2Vzcyk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgY2FzZSBMb2dpblJlc3VsdHMuSW52YWxpZFBhc3N3b3JkOlxuICAgIGNhc2UgTG9naW5SZXN1bHRzLlVua25vd25FcnJvcjpcbiAgICAgIHNjcmFwZXIuZW1pdFByb2dyZXNzKFNjYXBlclByb2dyZXNzVHlwZXMuTG9naW5GYWlsZWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yVHlwZTogbG9naW5SZXN1bHQgPT09IExvZ2luUmVzdWx0cy5JbnZhbGlkUGFzc3dvcmQgPyBTY3JhcGVyRXJyb3JUeXBlcy5JbnZhbGlkUGFzc3dvcmQgOlxuICAgICAgICAgIFNjcmFwZXJFcnJvclR5cGVzLkdlbmVyYWwsXG4gICAgICAgIGVycm9yTWVzc2FnZTogYExvZ2luIGZhaWxlZCB3aXRoICR7bG9naW5SZXN1bHR9IGVycm9yYCxcbiAgICAgIH07XG4gICAgY2FzZSBMb2dpblJlc3VsdHMuQ2hhbmdlUGFzc3dvcmQ6XG4gICAgICBzY3JhcGVyLmVtaXRQcm9ncmVzcyhTY2FwZXJQcm9ncmVzc1R5cGVzLkNoYW5nZVBhc3N3b3JkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvclR5cGU6IFNjcmFwZXJFcnJvclR5cGVzLkNoYW5nZVBhc3N3b3JkLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGxvZ2luIHJlc3VsdCBcIiR7bG9naW5SZXN1bHR9XCJgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZW5lcmFsRXJyb3IoKTogU2NhcGVyU2NyYXBpbmdSZXN1bHQge1xuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yVHlwZTogU2NyYXBlckVycm9yVHlwZXMuR2VuZXJhbCxcbiAgfTtcbn1cblxuY2xhc3MgQmFzZVNjcmFwZXJXaXRoQnJvd3NlciBleHRlbmRzIEJhc2VTY3JhcGVyIHtcbiAgLy8gTk9USUNFIC0gaXQgaXMgZGlzY291cmFnZSB0byB1c2UgYmFuZyAoISkgaW4gZ2VuZXJhbC4gSXQgaXMgdXNlZCBoZXJlIGJlY2F1c2VcbiAgLy8gYWxsIHRoZSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgYmFzZSBhc3N1bWUgaXMgaXQgbWFuZGF0b3J5LlxuICBwcm90ZWN0ZWQgYnJvd3NlciE6IEJyb3dzZXI7XG5cbiAgLy8gTk9USUNFIC0gaXQgaXMgZGlzY291cmFnZSB0byB1c2UgYmFuZyAoISkgaW4gZ2VuZXJhbC4gSXQgaXMgdXNlZCBoZXJlIGJlY2F1c2VcbiAgLy8gYWxsIHRoZSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgYmFzZSBhc3N1bWUgaXMgaXQgbWFuZGF0b3J5LlxuICBwcm90ZWN0ZWQgcGFnZSE6IFBhZ2U7XG5cbiAgcHJvdGVjdGVkIGdldFZpZXdQb3J0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogVklFV1BPUlRfV0lEVEgsXG4gICAgICBoZWlnaHQ6IFZJRVdQT1JUX0hFSUdIVCxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgZGVidWcoJ2luaXRpYWxpemUgc2NyYXBlcicpO1xuXG4gICAgbGV0IGVudjogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIGVudiA9IHsgREVCVUc6ICcqJywgLi4ucHJvY2Vzcy5lbnYgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5icm93c2VyICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wdGlvbnMuYnJvd3NlciAhPT0gbnVsbCkge1xuICAgICAgZGVidWcoJ3VzZSBjdXN0b20gYnJvd3NlciBpbnN0YW5jZSBwcm92aWRlZCBpbiBvcHRpb25zJyk7XG4gICAgICB0aGlzLmJyb3dzZXIgPSB0aGlzLm9wdGlvbnMuYnJvd3NlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXhlY3V0YWJsZVBhdGggPSB0aGlzLm9wdGlvbnMuZXhlY3V0YWJsZVBhdGggfHwgdW5kZWZpbmVkO1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMub3B0aW9ucy5hcmdzIHx8IFtdO1xuICAgICAgY29uc3QgeyB0aW1lb3V0IH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGNvbnN0IGhlYWRsZXNzID0gIXRoaXMub3B0aW9ucy5zaG93QnJvd3NlcjtcbiAgICAgIGRlYnVnKGBsYXVuY2ggYSBicm93c2VyIHdpdGggaGVhZGxlc3MgbW9kZSA9ICR7aGVhZGxlc3N9YCk7XG4gICAgICB0aGlzLmJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKHtcbiAgICAgICAgZW52LFxuICAgICAgICBoZWFkbGVzcyxcbiAgICAgICAgZXhlY3V0YWJsZVBhdGgsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXBhcmVCcm93c2VyKSB7XG4gICAgICBkZWJ1ZygnZXhlY3V0ZSBcXCdwcmVwYXJlQnJvd3NlclxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBvcHRpb25zJyk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMucHJlcGFyZUJyb3dzZXIodGhpcy5icm93c2VyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYnJvd3Nlcikge1xuICAgICAgZGVidWcoJ2ZhaWxlZCB0byBpbml0aWF0ZSBhIGJyb3dzZXIsIGV4aXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMuYnJvd3Nlci5wYWdlcygpO1xuICAgIGlmIChwYWdlcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdicm93c2VyIGhhcyBhbHJlYWR5IHBhZ2VzIG9wZW4sIHVzZSB0aGUgZmlyc3Qgb25lJyk7XG4gICAgICBbdGhpcy5wYWdlXSA9IHBhZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnY3JlYXRlIGEgbmV3IGJyb3dzZXIgcGFnZScpO1xuICAgICAgdGhpcy5wYWdlID0gYXdhaXQgdGhpcy5icm93c2VyLm5ld1BhZ2UoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZmF1bHRUaW1lb3V0KSB7XG4gICAgICB0aGlzLnBhZ2Uuc2V0RGVmYXVsdFRpbWVvdXQodGhpcy5vcHRpb25zLmRlZmF1bHRUaW1lb3V0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXBhcmVQYWdlKSB7XG4gICAgICBkZWJ1ZygnZXhlY3V0ZSBcXCdwcmVwYXJlUGFnZVxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBvcHRpb25zJyk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMucHJlcGFyZVBhZ2UodGhpcy5wYWdlKTtcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld1BvcnQoKTtcbiAgICBkZWJ1Zyhgc2V0IHZpZXdwb3J0IHRvIHdpZHRoICR7dmlld3BvcnQud2lkdGh9LCBoZWlnaHQgJHt2aWV3cG9ydC5oZWlnaHR9YCk7XG4gICAgYXdhaXQgdGhpcy5wYWdlLnNldFZpZXdwb3J0KHtcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgdGhpcy5wYWdlLm9uKCdyZXF1ZXN0ZmFpbGVkJywgKHJlcXVlc3QpID0+IHtcbiAgICAgIGRlYnVnKCdSZXF1ZXN0IGZhaWxlZDogJXMgJXMnLCByZXF1ZXN0LmZhaWx1cmUoKT8uZXJyb3JUZXh0LCByZXF1ZXN0LnVybCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIG5hdmlnYXRlVG8odXJsOiBzdHJpbmcsIHBhZ2U/OiBQYWdlLCB0aW1lb3V0PzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFnZVRvVXNlID0gcGFnZSB8fCB0aGlzLnBhZ2U7XG5cbiAgICBpZiAoIXBhZ2VUb1VzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLih0aW1lb3V0ID09PSBudWxsID8gbnVsbCA6IHsgdGltZW91dCB9KSB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcGFnZVRvVXNlLmdvdG8odXJsLCBvcHRpb25zKTtcblxuICAgIC8vIG5vdGU6IHJlc3BvbnNlIHdpbGwgYmUgbnVsbCB3aGVuIG5hdmlnYXRpbmcgdG8gc2FtZSB1cmwgd2hpbGUgY2hhbmdpbmcgdGhlIGhhc2ggcGFydC4gdGhlIGNvbmRpdGlvbiBiZWxvdyB3aWxsIGFsd2F5cyBhY2NlcHQgbnVsbCBhcyB2YWxpZCByZXN1bHQuXG4gICAgaWYgKHJlc3BvbnNlICE9PSBudWxsICYmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnN0YXR1cygpICE9PSBPS19TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIHRyeWluZyB0byBuYXZpZ2F0ZSB0byB1cmwgJHt1cmx9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBnZXRMb2dpbk9wdGlvbnMoX2NyZWRlbnRpYWxzOiBTY3JhcGVyQ3JlZGVudGlhbHMpOiBMb2dpbk9wdGlvbnMge1xuICAgIHRocm93IG5ldyBFcnJvcihgZ2V0TG9naW5PcHRpb25zKCkgaXMgbm90IGNyZWF0ZWQgaW4gJHt0aGlzLm9wdGlvbnMuY29tcGFueUlkfWApO1xuICB9XG5cbiAgYXN5bmMgZmlsbElucHV0cyhwYWdlT3JGcmFtZTogUGFnZSB8IEZyYW1lLCBmaWVsZHM6IHsgc2VsZWN0b3I6IHN0cmluZywgdmFsdWU6IHN0cmluZ31bXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1vZGlmaWVkID0gWy4uLmZpZWxkc107XG4gICAgY29uc3QgaW5wdXQgPSBtb2RpZmllZC5zaGlmdCgpO1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBmaWxsSW5wdXQocGFnZU9yRnJhbWUsIGlucHV0LnNlbGVjdG9yLCBpbnB1dC52YWx1ZSk7XG4gICAgaWYgKG1vZGlmaWVkLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5maWxsSW5wdXRzKHBhZ2VPckZyYW1lLCBtb2RpZmllZCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbG9naW4oY3JlZGVudGlhbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQcm9taXNlPFNjYXBlclNjcmFwaW5nUmVzdWx0PiB7XG4gICAgaWYgKCFjcmVkZW50aWFscyB8fCAhdGhpcy5wYWdlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlR2VuZXJhbEVycm9yKCk7XG4gICAgfVxuXG4gICAgZGVidWcoJ2V4ZWN1dGUgbG9naW4gcHJvY2VzcycpO1xuICAgIGNvbnN0IGxvZ2luT3B0aW9ucyA9IHRoaXMuZ2V0TG9naW5PcHRpb25zKGNyZWRlbnRpYWxzKTtcblxuICAgIGlmIChsb2dpbk9wdGlvbnMudXNlckFnZW50KSB7XG4gICAgICBkZWJ1Zygnc2V0IGN1c3RvbSB1c2VyIGFnZW50IHByb3ZpZGVkIGluIG9wdGlvbnMnKTtcbiAgICAgIGF3YWl0IHRoaXMucGFnZS5zZXRVc2VyQWdlbnQobG9naW5PcHRpb25zLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgZGVidWcoJ25hdmlnYXRlIHRvIGxvZ2luIHVybCcpO1xuICAgIGF3YWl0IHRoaXMubmF2aWdhdGVUbyhsb2dpbk9wdGlvbnMubG9naW5VcmwpO1xuICAgIGlmIChsb2dpbk9wdGlvbnMuY2hlY2tSZWFkaW5lc3MpIHtcbiAgICAgIGRlYnVnKCdleGVjdXRlIFxcJ2NoZWNrUmVhZGluZXNzXFwnIGludGVyY2VwdG9yIHByb3ZpZGVkIGluIGxvZ2luIG9wdGlvbnMnKTtcbiAgICAgIGF3YWl0IGxvZ2luT3B0aW9ucy5jaGVja1JlYWRpbmVzcygpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2luT3B0aW9ucy5zdWJtaXRCdXR0b25TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRlYnVnKCd3YWl0IHVudGlsIHN1Ym1pdCBidXR0b24gaXMgYXZhaWxhYmxlJyk7XG4gICAgICBhd2FpdCB3YWl0VW50aWxFbGVtZW50Rm91bmQodGhpcy5wYWdlLCBsb2dpbk9wdGlvbnMuc3VibWl0QnV0dG9uU2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGxldCBsb2dpbkZyYW1lT3JQYWdlOiAoUGFnZSB8IEZyYW1lIHwgbnVsbCkgPSB0aGlzLnBhZ2U7XG4gICAgaWYgKGxvZ2luT3B0aW9ucy5wcmVBY3Rpb24pIHtcbiAgICAgIGRlYnVnKCdleGVjdXRlIFxcJ3ByZUFjdGlvblxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBsb2dpbiBvcHRpb25zJyk7XG4gICAgICBsb2dpbkZyYW1lT3JQYWdlID0gYXdhaXQgbG9naW5PcHRpb25zLnByZUFjdGlvbigpIHx8IHRoaXMucGFnZTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnZmlsbCBsb2dpbiBjb21wb25lbnRzIGlucHV0IHdpdGggcmVsZXZhbnQgdmFsdWVzJyk7XG4gICAgYXdhaXQgdGhpcy5maWxsSW5wdXRzKGxvZ2luRnJhbWVPclBhZ2UsIGxvZ2luT3B0aW9ucy5maWVsZHMpO1xuICAgIGRlYnVnKCdjbGljayBvbiBsb2dpbiBzdWJtaXQgYnV0dG9uJyk7XG4gICAgaWYgKHR5cGVvZiBsb2dpbk9wdGlvbnMuc3VibWl0QnV0dG9uU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhd2FpdCBjbGlja0J1dHRvbihsb2dpbkZyYW1lT3JQYWdlLCBsb2dpbk9wdGlvbnMuc3VibWl0QnV0dG9uU2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBsb2dpbk9wdGlvbnMuc3VibWl0QnV0dG9uU2VsZWN0b3IoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0UHJvZ3Jlc3MoU2NhcGVyUHJvZ3Jlc3NUeXBlcy5Mb2dnaW5nSW4pO1xuXG4gICAgaWYgKGxvZ2luT3B0aW9ucy5wb3N0QWN0aW9uKSB7XG4gICAgICBkZWJ1ZygnZXhlY3V0ZSBcXCdwb3N0QWN0aW9uXFwnIGludGVyY2VwdG9yIHByb3ZpZGVkIGluIGxvZ2luIG9wdGlvbnMnKTtcbiAgICAgIGF3YWl0IGxvZ2luT3B0aW9ucy5wb3N0QWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCd3YWl0IGZvciBwYWdlIG5hdmlnYXRpb24nKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JOYXZpZ2F0aW9uKHRoaXMucGFnZSk7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NoZWNrIGxvZ2luIHJlc3VsdCcpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBnZXRDdXJyZW50VXJsKHRoaXMucGFnZSwgdHJ1ZSk7XG4gICAgY29uc3QgbG9naW5SZXN1bHQgPSBhd2FpdCBnZXRLZXlCeVZhbHVlKGxvZ2luT3B0aW9ucy5wb3NzaWJsZVJlc3VsdHMsIGN1cnJlbnQsIHRoaXMucGFnZSk7XG4gICAgZGVidWcoYGhhbmRsZSBsb2dpbiByZXN1bHRzICR7bG9naW5SZXN1bHR9YCk7XG4gICAgcmV0dXJuIGhhbmRsZUxvZ2luUmVzdWx0KHRoaXMsIGxvZ2luUmVzdWx0KTtcbiAgfVxuXG4gIGFzeW5jIHRlcm1pbmF0ZShfc3VjY2VzczogYm9vbGVhbikge1xuICAgIGRlYnVnKGB0ZXJtaW5hdGluZyBicm93c2VyIHdpdGggc3VjY2VzcyA9ICR7X3N1Y2Nlc3N9YCk7XG4gICAgdGhpcy5lbWl0UHJvZ3Jlc3MoU2NhcGVyUHJvZ3Jlc3NUeXBlcy5UZXJtaW5hdGluZyk7XG5cbiAgICBpZiAoIV9zdWNjZXNzICYmICEhdGhpcy5vcHRpb25zLnN0b3JlRmFpbHVyZVNjcmVlblNob3RQYXRoKSB7XG4gICAgICBkZWJ1ZyhgY3JlYXRlIGEgc25hcHNob3QgYmVmb3JlIHRlcm1pbmF0ZWQgaW4gJHt0aGlzLm9wdGlvbnMuc3RvcmVGYWlsdXJlU2NyZWVuU2hvdFBhdGh9YCk7XG4gICAgICBhd2FpdCB0aGlzLnBhZ2Uuc2NyZWVuc2hvdCh7XG4gICAgICAgIHBhdGg6IHRoaXMub3B0aW9ucy5zdG9yZUZhaWx1cmVTY3JlZW5TaG90UGF0aCxcbiAgICAgICAgZnVsbFBhZ2U6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYnJvd3Nlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYnJvd3Nlci5jbG9zZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VTY3JhcGVyV2l0aEJyb3dzZXIgfTtcbiJdfQ==